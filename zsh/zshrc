# .zshrc
# This file is for interactive shell configuration. See https://unix.stackexchange.com/a/71258

# Uncomment this line and "zprof" at the end of this file to profile zsh startup time
# zmodload zsh/zprof

ZSH_THEME_BACKGROUND="dark"
case "$TERM_PROGRAM" in
    (iTerm.app)
        ;;
    (vscode)
        ZSH_THEME_NO_SPECIAL_CHARACTERS="true"
        ZSH_THEME_BACKGROUND="light"
        ;;
    (*)
        ZSH_THEME_NO_SPECIAL_CHARACTERS="true"
        ;;
esac
export ZSH_THEME_BACKGROUND

# disable shell-builtin "r" so I can access the "r" executable
disable r

# "log" is the new way to access the syslog in OSX
disable log

# Set language/locale
# See https://stackoverflow.com/a/30479702
export LANG="en_GB.UTF-8"
export LC_NUMERIC="de_AT.UTF-8"
export LC_TIME="de_AT.UTF-8"
export LC_MONETARY="de_AT.UTF-8"
export LC_MEASUREMENT="de_AT.UTF-8"

# Platform-specific configuration
if [[ "$OSTYPE" =~ ^darwin ]] then
  # Mac OS X configuration

  # Disable auto-cleanup when upgrading homebrew formulas
  export HOMEBREW_NO_INSTALL_CLEANUP=1
  # Disable homebrew auto-update
  export HOMEBREW_NO_AUTO_UPDATE=1

  # Use MacVim to edit files, and give focus back to iTerm after closing
  export EDITOR="${HOMEBREW_PREFIX}/bin/mvim -p --nofork -c ActivateTerminalOnExit"
  export VISUAL="${EDITOR}"
  alias mvim="${HOMEBREW_PREFIX}/bin/mvim -p"

  # stay in console for git commit messages
  export GIT_EDITOR="${HOMEBREW_PREFIX}/bin/vim +0"

  EMACSCLIENT="${HOMEBREW_PREFIX}/bin/emacsclient"
  function emacs_is_running {
      $EMACSCLIENT --eval "t" &>/dev/null
  }
  function emacs_ensure_running {
      if ! emacs_is_running; then
          printf "Starting Emacs server"
          /usr/bin/open --background /Applications/Emacs.app
          while ! emacs_is_running; do
              printf "."
              /bin/sleep 0.05
          done
          printf "\n"
      fi
  }
  function e {
      emacs_ensure_running

      # Focus Emacs window
      # Do this first, because if the Emacs GUI was hidden with CMD+H,
      # opening a file with emacsclient will block until the GUI is activated by the user.
      $EMACSCLIENT --eval "(x-focus-frame nil)" >/dev/null

      if [[ -z "${@}" ]] then
          # No args: just focus Emacs for now
          # $EMACSCLIENT --eval "(list-directory \"${PWD}\")"
      else
          $EMACSCLIENT --no-wait "${@}"
      fi
  }
  function eo {
      e -c "~/org/inbox.org"
  }
  function ea {
      e -c --eval "(org-agenda-list)" "(delete-other-windows)"
      # TODO: focus agenda buffer if it is already open
      # See also https://emacs.stackexchange.com/a/3472
  }
  function ec {
      # Only pass -c if emacs is already running,
      # otherwise we end up with an extra empty window.
      if emacs_is_running; then
          e -c "${@}"
      else
          e "${@}"
      fi
  }

  function dash {
      /usr/bin/open "dash://$1"
  }

  alias dtw='$HOME/server/dango/transmission-web.sh -f'
  alias dtr='$HOME/server/dango/transmission-remote.sh'
  alias airport='/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport'
  alias pbclear='echo -n | pbcopy'

  JR_OPEN="/usr/bin/open"

elif [[ "$OSTYPE" =~ ^freebsd ]] then
  # FreeBSD configuration

  export EDITOR='/usr/local/bin/vim'

  # Show full command name in top by default (-a)
  export TOP='-a'

elif [[ "$OSTYPE" =~ ^linux ]] then
  # Linux configuration

  export EDITOR='/usr/bin/vim'

  JR_OPEN="xdg-open"

  alias gdate="date"

  function m_cmd {
      vim "${@}"
  }

  #########
  # NixOS #
  #########
  # # Clear right-side prompt
  # RPS1=
  # Terminfo
  if [[ "$TERM_PROGRAM" == "iTerm.app" ]] then
      TERM=iTerm2.app
  fi

  ##########
  # Ubuntu #
  ##########
  if [[ "$(lsb_release -s -i)" = "Ubuntu" ]] then
      alias fd=fdfind
      alias yt-dlp=$HOME/youtube-dl/bin/yt-dlp
  fi

  ###############################
  # Windows Subsystem for Linux #
  ###############################
  if [[ -v WSL_DISTRO_NAME ]] then

      if [[ "$PWD" == "/mnt/c/Windows" ]] then
          cd ~
      fi
      if [[ "$PWD" == "/mnt/c/Windows/System32" ]] then
          cd ~
      fi

      # Disable C-s handling by the terminal
      # (C-s sends signal XOFF to stop output, C-q sends XON to resume)
      # See https://unix.stackexchange.com/a/72092
      stty -ixon

      alias explorer="/mnt/c/Windows/explorer.exe"

      function o {
          local path
          if (( $# == 0 )) then
              path="$PWD"
          elif (( $# == 1 )) then
              path="$1"
          else
              echo "Error: I don't know what to do with multiple arguments :("
              return 2
          fi
          /mnt/c/Windows/explorer.exe "$(/usr/bin/wslpath -w "$path")"
      }

  fi
fi


# NOTE: For the option "-F" to work properly we need "less" version >= 530
export PAGER="less -SF"
export LESS="-R"

# Fix GPG (it needs to know where to display the passphrase dialog)
# See also https://www.gnupg.org/(it)/documentation/manuals/gnupg/Common-Problems.html
export GPG_TTY="$(tty)"

export ZFS_COLOR=1
alias color_test='for code in {000..255}; do print -P -- "$code: %F{$code}Test%f"; done | column -c 100'

# Define function "o" if not yet defined
if ! typeset -f o > /dev/null; then
    function o {
        if [[ -z "${@}" ]] then
            "${JR_OPEN}" .
        else
            "${JR_OPEN}" "${@}"
        fi
    }
fi

# Define function "m_cmd" if not yet defined
if ! typeset -f m_cmd > /dev/null; then
    function m_cmd {
        gvim -g "${@}"
    }
fi

# TODO: Functions m2, m3, ... which open in the 2nd, 3rd, ... vim server in the serverlist
# TODO: A function "ms" that lists vim servers, and what project each is associated to.
function m {
    # TODO: When starting a new instance, add the code to switch back to the terminal on exit
    # TODO: Maybe use this server: $(vim --serverlist|tail -n 1)   (latest one started)
    # TODO: Maybe it's possible to use a specific vim server per "project"?
    #       A "project" might be each folder in "~/code", or each folder in "~" if it's not in "~/code" (define a list of "project roots", e.g. ["~/code", "~/Documents/Uni/*/", ..., "~"], to match against)
    #       Other idea:
    #           Use "mvim" to manually open a new vim instance for a project.
    #           "m" just picks the most appropriate open vim server (one with the same project; or if none exists, the first one)
    #           That's probably better than opening new project-specific instances automatically?
    if [[ -z "${@}" ]] then
        if [[ -z "$(m_cmd --serverlist)" ]] then
            # No vim instances running? start a new one
            m_cmd
        else
            # m_cmd --remote-send '<Esc>:tabnew<CR>' --remote-expr 'foreground()'
            m_cmd --remote-send '<Esc>:tabnew<CR>:call foreground()<CR>'
        fi
    else
        if [[ -z "$(m_cmd --serverlist)" ]] then
            # No vim instances running? start a new one
            m_cmd "${@}"
        else
            m_cmd --remote-tab-silent "${@}"
        fi
    fi
}
alias vi="vim"

function mkm {
    if (( $# != 1 )) then
        echo "mkm: please pass exactly one argument"
        return 1
    fi
    local cursor_cmd
    cursor_cmd="$(mk -p vim "$1")"
    if (( $? == 0 )) then
        m "+${cursor_cmd}" "$1"
    fi
}

function mkec {
    if (( $# != 1 )) then
        echo "mkec: please pass exactly one argument"
        return 1
    fi
    local cursor_pos
    cursor_pos="$(mk -p emacs "$1")"
    if (( $? == 0 )) then
        ec "+${cursor_pos}" "$1"
    fi
}

function mke {
    if (( $# != 1 )) then
        echo "mke: please pass exactly one argument"
        return 1
    fi
    local cursor_pos
    cursor_pos="$(mk -p emacs "$1")"
    if (( $? == 0 )) then
        e "+${cursor_pos}" "$1"
    fi
}

# Open today's journal entry.
# Can shift day with Â±number as first argument (e.g., "mj -1" for yesterday's entry).
function mj {
    if [[ ! "${1}" =~ ^[+-][0-9]+$ ]] then
        1='+0'
    fi
    local timestamp
    timestamp="$(gdate +%s)"
    timestamp="$(( $timestamp + ( $1 * 60 * 60 * 24 ) ))"
    (
        export DATE="$(gdate --date="@${timestamp}" "+%Y-%m-%d")"
        export TAG="$(gdate --date="@${timestamp}" "+%Y/%m/%d")"
        export WEEKDAY="$(/usr/bin/env LC_TIME=en_GB.UTF-8 gdate --date="@${timestamp}" "+%A")"
        cd "${HOME}/kb/Journal/" && vim "./journal-${DATE}".md
    )
}







##########################################################################
# work in progress: getting rid of oh-my-zsh


# Figure out the SHORT hostname
if [[ "$OSTYPE" = darwin* ]]; then
  # macOS's $HOST changes with dhcp, etc. Use ComputerName if possible.
  SHORT_HOST=$(scutil --get ComputerName 2>/dev/null) || SHORT_HOST=${HOST/.*/}
else
  SHORT_HOST=${HOST/.*/}
fi

ZSH_CACHE_DIR="${HOME}/.cache/zsh"
if [[ ! -d "${ZSH_CACHE_DIR}" ]]; then
    mkdir -p "${ZSH_CACHE_DIR}"
fi
# TODO: move to cache dir?
ZSH_COMPDUMP="${HOME}/.zcompdump-${SHORT_HOST}-${ZSH_VERSION}"

# Load all stock functions (from $fpath files) called below.
autoload -U compaudit compinit

# TODO: rename variable to ZSH
ZSH_CUSTOM="${JR_DOTFILES}/zsh/custom"

fpath=("${JR_DOTFILES}/zsh/completions" $fpath)
fpath=("${ZSH_CUSTOM}/plugins/zaw" $fpath)
fpath=("${ZSH_CUSTOM}/plugins/zsh-dwim" $fpath)
fpath=("${ZSH_CUSTOM}/plugins/zsh-syntax-highlighting" $fpath)
fpath=("${ZSH_CUSTOM}/plugins/nix" $fpath)
fpath=("${ZSH_CUSTOM}/plugins/nix-shell" $fpath)

source "${JR_DOTFILES}/zsh/lib/compfix.zsh"
# If completion insecurities exist, warn the user
handle_completion_insecurities
# Load only from secure directories
compinit -i -C -d "${ZSH_COMPDUMP}"

source "${JR_DOTFILES}/zsh/lib/clipboard.zsh"
source "${JR_DOTFILES}/zsh/lib/completion.zsh"
source "${JR_DOTFILES}/zsh/lib/git.zsh"
source "${JR_DOTFILES}/zsh/lib/spectrum.zsh"
source "${JR_DOTFILES}/zsh/lib/termsupport.zsh"

source "${ZSH_CUSTOM}/plugins/zaw/zaw.plugin.zsh"
source "${ZSH_CUSTOM}/plugins/zsh-dwim/zsh-dwim.plugin.zsh"
source "${ZSH_CUSTOM}/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.plugin.zsh"
source "${ZSH_CUSTOM}/plugins/nix/nix.plugin.zsh"
source "${ZSH_CUSTOM}/plugins/nix-shell/nix-shell.plugin.zsh"

# Load all of your custom configurations from custom/  (TODO: replace loop by explicit list)
for config_file in $ZSH_CUSTOM/*.zsh(N); do
  source $config_file
done
unset config_file

# Load the theme
source "$ZSH_CUSTOM/kagami.zsh-theme"


##########################################################################






## History file configuration
[ -z "$HISTFILE" ] && HISTFILE="$HOME/.zsh_history"
HISTSIZE=1000000
SAVEHIST=1000000

## History command configuration
setopt extended_history       # record timestamp of command in HISTFILE
setopt hist_expire_dups_first # delete duplicates first when HISTFILE size exceeds HISTSIZE
setopt hist_ignore_dups       # ignore duplicated commands history list
setopt hist_ignore_space      # ignore commands that start with space
setopt hist_verify            # show command with history expansion to user before running it
setopt inc_append_history     # add commands to HISTFILE in order of execution
setopt share_history          # share command history data



# Find current project's root folder.
function is_project_root {
    [[ (-e "${1}/.git") || (-e "${1}/.zsh_history") || ("${1:P}" = "${HOME:P}") || ("$1" == "/") ]]
}
function find_project_root {
    local dir="${1:-$PWD}"
    dir="${dir:P}"  # get realpath of directory
    while ! is_project_root "$dir"; do
        dir="${dir:h}"
    done
    printf "%s\n" "$dir"
}
# Go to the current project's root folder.
function cdr {
    cd "$(find_project_root)"
}
function set_histfile_dir {
    local dir="$1"
    if [[ "$dir" = "/" ]] then
        dir="$HOME"
    fi
    local project_histfile="${dir}/.zsh_history"
    if [[ (! -w "$project_histfile") && ((-e "$project_histfile") || (! -w "${project_histfile:h}")) ]] then
        # project_histfile exists and isn't writable, or
        # project_histfile doesn't exist and the parent directory isn't writable
        # => use the default location instead
        project_histfile="${HOME}/.zsh_history"
    fi
    # Switch to project histfile.
    # We follow symbolic links. This makes it possible to link the histories of
    # different folders. If we didn't follow the link, zsh would replace it
    # with a regular file on the next write.
    local real_project_histfile="${project_histfile:P}"
    if [[ ${HISTFILE:P} != "${real_project_histfile}" ]] then
        fc -Pp "${real_project_histfile}"
        echo "New HISTFILE: $HISTFILE"
    fi
}
function set_project_histfile {
    set_histfile_dir "$(find_project_root)"
}

function project_build_root {
    local project_root="$(find_project_root)"
    local project_name="${project_root:t}"
    local dir="${HOME}/.cache/build/${project_name}"
    printf "%s\n" "$dir"
}
# Usage:
#   cdb [CONFIG]
# Go to the current project's build directory.
# CONFIG: the build configuration, defaults to "debug".
function cdb {
    local build_cfg="${1:-debug}"
    local build_dir="$(project_build_root)/${build_cfg}"
    if [[ ! -e "${build_dir}" ]] then
        echo "cdb: creating new build directory: ${build_dir}"
        /bin/mkdir -p "${build_dir}"
        # TODO: link .git to the project folder if necessary.
    fi
    cd "${build_dir}"
}

# Use per-project zsh history
set_project_histfile
function chpwd {
    # Note: chpwd is called whenever the current directory changes
    if [[ $PWD != $OLDPWD ]] then
        set_project_histfile
    fi
}

setopt complete_aliases

if [[ "$OSTYPE" =~ ^darwin ]] then
    # compdef seems to work only after loading oh-my-zsh
    alias s="/usr/bin/open -a Skim"
    compdef '_files -g \*.pdf' s
fi

# # iTerm shell integration, see https://iterm2.com/documentation-shell-integration.html
# if [[ "$TERM_PROGRAM" == "iTerm.app" ]] then
#     source "${JR_DOTFILES}/zsh/iterm2_shell_integration.zsh"
# fi

# Uncomment this line and "zmodload zsh/zprof" at the top of this file to profile zsh startup time
# zprof
