# .zshrc
# This file is for interactive shell configuration. See https://unix.stackexchange.com/a/71258

# Uncomment this line and "zprof" at the end of this file to profile zsh startup time
# zmodload zsh/zprof

# Determine whether the background of the current terminal is dark or light (affects color choices),
# and whether we want to use non-ASCII characters in the prompt.
ZSH_THEME_BACKGROUND="dark"
case "$TERM_PROGRAM" in
    (iTerm.app)
        ;;
    (vscode)
        ZSH_THEME_NO_SPECIAL_CHARACTERS="true"
        ZSH_THEME_BACKGROUND="light"
        ;;
    (*)
        ZSH_THEME_NO_SPECIAL_CHARACTERS="true"
        ;;
esac
export ZSH_THEME_BACKGROUND

# Disable builtin command "r" so I can access the "r" executable.
disable r

# Disable builtin command "log" (on macOS, the command to access the syslog is also called "log").
disable log

# Set language/locale
# See https://stackoverflow.com/a/30479702
export LANG="en_GB.UTF-8"
export LC_NUMERIC="de_AT.UTF-8"
export LC_TIME="de_AT.UTF-8"
export LC_MONETARY="de_AT.UTF-8"
export LC_MEASUREMENT="de_AT.UTF-8"

# Platform-specific configuration
if [[ "$OSTYPE" = darwin* ]] then
  # macOS configuration

  # Disable auto-cleanup when upgrading homebrew formulas
  export HOMEBREW_NO_INSTALL_CLEANUP=1
  # Disable homebrew auto-update
  export HOMEBREW_NO_AUTO_UPDATE=1

  EMACSCLIENT="${HOMEBREW_PREFIX}/bin/emacsclient"
  function emacs_is_running {
      $EMACSCLIENT --eval "t" &>/dev/null
  }
  function emacs_ensure_running {
      if ! emacs_is_running; then
          printf "Starting Emacs server"
          /usr/bin/open --background /Applications/Emacs.app
          while ! emacs_is_running; do
              printf "."
              /bin/sleep 0.05
          done
          printf "\n"
      fi
  }
  function e {
      emacs_ensure_running

      # Focus Emacs window
      # Do this first, because if the Emacs GUI was hidden with CMD+H,
      # opening a file with emacsclient will block until the GUI is activated by the user.
      $EMACSCLIENT --eval "(x-focus-frame nil)" >/dev/null

      if [[ -z "${@}" ]] then
          # No args: just focus Emacs for now
          # $EMACSCLIENT --eval "(list-directory \"${PWD}\")"
      else
          $EMACSCLIENT --no-wait "${@}"
      fi
  }
  function eo {
      e -c "~/org/inbox.org"
  }
  function ea {
      e -c --eval "(org-agenda-list)" "(delete-other-windows)"
      # TODO: focus agenda buffer if it is already open
      # See also https://emacs.stackexchange.com/a/3472
  }
  function ec {
      # Only pass -c if emacs is already running,
      # otherwise we end up with an extra empty window.
      if emacs_is_running; then
          e -c "${@}"
      else
          e "${@}"
      fi
  }

  function dash {
      /usr/bin/open "dash://$1"
  }

  alias dtw='$HOME/server/dango/transmission-web.sh -f'
  alias dtr='$HOME/server/dango/transmission-remote.sh'
  alias airport='/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport'
  alias pbclear='echo -n | pbcopy'

  JR_OPEN="/usr/bin/open"

elif [[ "$OSTYPE" = freebsd* ]] then
  # FreeBSD configuration

  # Show full command name in top by default (-a)
  export TOP='-a'

elif [[ "$OSTYPE" = linux* ]] then
  # Linux configuration

  JR_OPEN="xdg-open"

  alias gdate="date"

  #########
  # NixOS #
  #########
  # # Clear right-side prompt
  # RPS1=
  # Terminfo
  if [[ "$TERM_PROGRAM" == "iTerm.app" ]] then
      TERM=iTerm2.app
  fi

  ###############################
  # Windows Subsystem for Linux #
  ###############################
  if [[ -v WSL_DISTRO_NAME ]] then

      if [[ "$PWD" == "/mnt/c/Windows" ]] then
          cd ~
      fi
      if [[ "$PWD" == "/mnt/c/Windows/System32" ]] then
          cd ~
      fi

      # Disable C-s handling by the terminal
      # (C-s sends signal XOFF to stop output, C-q sends XON to resume)
      # See https://unix.stackexchange.com/a/72092
      stty -ixon

      alias explorer="/mnt/c/Windows/explorer.exe"

      function o {
          local path
          if (( $# == 0 )) then
              path="$PWD"
          elif (( $# == 1 )) then
              path="$1"
          else
              echo "Error: I don't know what to do with multiple arguments :("
              return 2
          fi
          /mnt/c/Windows/explorer.exe "$(/usr/bin/wslpath -w "$path")"
      }

  fi
fi


# NOTE: For the option "-F" to work properly we need "less" version >= 530
export PAGER="less -SF"
export LESS="-R"

# Fix GPG (it needs to know where to display the passphrase dialog)
# See also https://www.gnupg.org/(it)/documentation/manuals/gnupg/Common-Problems.html
export GPG_TTY="$(tty)"

export ZFS_COLOR=1
alias color_test='for code in {000..255}; do print -P -- "$code: %F{$code}Test%f"; done | column -c 100'

# Define function "o" if not yet defined
if ! typeset -f o > /dev/null; then
    function o {
        if [[ -z "${@}" ]] then
            "${JR_OPEN}" .
        else
            "${JR_OPEN}" "${@}"
        fi
    }
fi

setopt complete_aliases

# Figure out the SHORT hostname
if [[ "$OSTYPE" = darwin* ]]; then
  # macOS's $HOST changes with dhcp, etc. Use ComputerName if possible.
  SHORT_HOST=$(scutil --get ComputerName 2>/dev/null) || SHORT_HOST=${HOST/.*/}
else
  SHORT_HOST=${HOST/.*/}
fi

ZSH_CACHE_DIR="${HOME}/.cache/zsh"
if [[ ! -d "${ZSH_CACHE_DIR}" ]]; then
    mkdir -p "${ZSH_CACHE_DIR}"
fi

ZSH_COMPDUMP="${ZSH_CACHE_DIR}/zcompdump-${SHORT_HOST}-${ZSH_VERSION}"

# Load all stock functions (from $fpath files) called below.
autoload -U compaudit compinit

ZSH="${JR_DOTFILES}/zsh"

fpath=("${ZSH}/completions" $fpath)
fpath=("${ZSH}/plugins/zaw" $fpath)
fpath=("${ZSH}/plugins/zsh-dwim" $fpath)
fpath=("${ZSH}/plugins/zsh-syntax-highlighting" $fpath)
fpath=("${ZSH}/plugins/nix" $fpath)
fpath=("${ZSH}/plugins/nix-shell" $fpath)

source "${ZSH}/lib/compfix.zsh"
# If completion insecurities exist, warn the user
handle_completion_insecurities
# Load only from secure directories
compinit -i -C -d "${ZSH_COMPDUMP}"

# External config files
source "${ZSH}/lib/clipboard.zsh"
source "${ZSH}/lib/completion.zsh"
source "${ZSH}/lib/git.zsh"
source "${ZSH}/lib/spectrum.zsh"
source "${ZSH}/lib/termsupport.zsh"

source "${ZSH}/plugins/zaw/zaw.plugin.zsh"
source "${ZSH}/plugins/zsh-dwim/zsh-dwim.plugin.zsh"
source "${ZSH}/plugins/nix/nix.plugin.zsh"
source "${ZSH}/plugins/nix-shell/nix-shell.plugin.zsh"

# My config files
source "${ZSH}/conf/ag.zsh"
source "${ZSH}/conf/directories.zsh"
source "${ZSH}/conf/disable-autocorrection.zsh"
source "${ZSH}/conf/dwim.zsh"
source "${ZSH}/conf/iterm-tab-color.zsh"
source "${ZSH}/conf/key-bindings.zsh"
[[ "$OSTYPE" = darwin* ]] && source "${ZSH}/conf/macos.zsh"
source "${ZSH}/conf/misc.zsh"
source "${ZSH}/conf/project.zsh"
source "${ZSH}/conf/rvm.zsh"
source "${ZSH}/conf/sudo-prompt.zsh"
source "${ZSH}/conf/tmux.zsh"
source "${ZSH}/conf/vim.zsh"
source "${ZSH}/conf/zaw.zsh"

## History file configuration
[[ -z "$HISTFILE" ]] && HISTFILE="$HOME/.zsh_history"
HISTSIZE=1000000
SAVEHIST=1000000

## History command configuration
setopt extended_history       # record timestamp of command in HISTFILE
setopt hist_expire_dups_first # delete duplicates first when HISTFILE size exceeds HISTSIZE
setopt hist_ignore_dups       # ignore duplicated commands history list
setopt hist_ignore_space      # ignore commands that start with space
setopt hist_verify            # show command with history expansion to user before running it
setopt inc_append_history     # add commands to HISTFILE in order of execution
setopt share_history          # share command history data

## Use per-project zsh history
set_project_histfile
function chpwd {
    # Note: chpwd is called whenever the current directory changes
    if [[ $PWD != $OLDPWD ]] then
        set_project_histfile
    fi
}

source "${ZSH}/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.plugin.zsh"

# Load the theme (sets the prompt and the syntax highlighting colors)
source "${ZSH}/conf/theme.zsh"

# Uncomment this line and "zmodload zsh/zprof" at the top of this file to profile zsh startup time
# zprof
